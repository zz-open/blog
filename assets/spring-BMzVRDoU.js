import{_ as p}from"./ValaxyMain.vue_vue_type_style_index_0_lang-BvyuMnyR.js";import{u as h,o as m,c as g,w as l,r,g as e,h as a,f as b,p as u}from"./app-boVvO3tb.js";import"./YunComment.vue_vue_type_style_index_0_lang-CrsBtAxv.js";import"./index-C5okkQwF.js";import"./YunPageHeader.vue_vue_type_script_setup_true_lang-CFbN6BoV.js";import"./post-nLiiti9w.js";const P={__name:"spring",setup(f,{expose:c}){const t=JSON.parse('{"title":"Spring 面试问题","description":"","frontmatter":{},"headers":[{"level":2,"title":"@Autowired和@Resource区别?","slug":"autowired和-resource区别","link":"#autowired和-resource区别","children":[]},{"level":2,"title":"2.Spring循环依赖如何解决？","slug":"_2-spring循环依赖如何解决","link":"#_2-spring循环依赖如何解决","children":[{"level":3,"title":"第一级缓存的作用？","slug":"第一级缓存的作用","link":"#第一级缓存的作用","children":[]},{"level":3,"title":"存储什么数据？","slug":"存储什么数据","link":"#存储什么数据","children":[]},{"level":3,"title":"第二级缓存的作用？","slug":"第二级缓存的作用","link":"#第二级缓存的作用","children":[]},{"level":3,"title":"存储什么数据？","slug":"存储什么数据-1","link":"#存储什么数据-1","children":[]},{"level":3,"title":"第三级缓存的作用？","slug":"第三级缓存的作用","link":"#第三级缓存的作用","children":[]},{"level":3,"title":"存储什么数据？","slug":"存储什么数据-2","link":"#存储什么数据-2","children":[]}]},{"level":2,"title":"3.","slug":"_3","link":"#_3","children":[]}],"relativePath":"pages/posts/java-stack/interview/spring.md","path":"/home/runner/work/blog/blog/packages/valaxy-blog/pages/posts/java-stack/interview/spring.md","lastUpdated":1732447053000}'),s=h(),i=t.frontmatter||{};return s.meta.frontmatter=Object.assign(s.meta.frontmatter||{},t.frontmatter||{}),u("pageData",t),u("valaxy:frontmatter",i),globalThis.$frontmatter=i,c({frontmatter:{}}),(n,o)=>{const d=p;return m(),g(d,{frontmatter:b(i)},{"main-content-md":l(()=>o[0]||(o[0]=[e("h1",{id:"spring-面试问题",tabindex:"-1"},[a("Spring 面试问题 "),e("a",{class:"header-anchor",href:"#spring-面试问题","aria-label":'Permalink to "Spring 面试问题"'},"​")],-1),e("h2",{id:"autowired和-resource区别",tabindex:"-1"},[a("@Autowired和@Resource区别? "),e("a",{class:"header-anchor",href:"#autowired和-resource区别","aria-label":'Permalink to "@Autowired和@Resource区别?"'},"​")],-1),e("h4",{id:"autowired",tabindex:"-1"},[a("@Autowired "),e("a",{class:"header-anchor",href:"#autowired","aria-label":'Permalink to "@Autowired"'},"​")],-1),e("ul",null,[e("li",null,"@AutoWired是spring中注解，主要是使用类型来进行注入"),e("li",null,"注解是按类型装配依赖对象，默认情况下它要求依赖对象必须存在，如果允许null值，可以设置它required属性为false。"),e("li",null,"@AutoWired不支持基于name注入，如果需要准确定位bean注入，需要与@Qualifier配合使用")],-1),e("h4",{id:"resource",tabindex:"-1"},[a("@Resource "),e("a",{class:"header-anchor",href:"#resource","aria-label":'Permalink to "@Resource"'},"​")],-1),e("ul",null,[e("li",null,[a("@Resource是JDK1.6支持的注解，默认使用名称进行注入，如果没有匹配到name属性指定，则使用类型注入。"),e("strong",null,"@Resource虽然是JDK原生支持的，但是注解处理器是Spring提供")]),e("li",null,"@Resource默认使用name属性注入，使用注解时可以指定name属性，如果没指定该属性，则根据注解位置情况使用字段名或者属性名（setter)注入"),e("li",null,"@Resource根据name属性无法注入时，会使用类型进行注入。但是一旦指定name属性，则不会再使用name属性注入")],-1),e("h4",{id:"spring两种注入类型",tabindex:"-1"},[a("Spring两种注入类型 "),e("a",{class:"header-anchor",href:"#spring两种注入类型","aria-label":'Permalink to "Spring两种注入类型"'},"​")],-1),e("ul",null,[e("li",null,"byName:通过参数名自动注入，如果一个bean的name与另一个bean的property相同，就自动注入"),e("li",null,"byType:通过参数的数据类型自动注入，如果一个bean的数据类型与另外一个bean的property属性的数据类型兼容，就自动注入")],-1),e("h2",{id:"_2-spring循环依赖如何解决",tabindex:"-1"},[a("2.Spring循环依赖如何解决？ "),e("a",{class:"header-anchor",href:"#_2-spring循环依赖如何解决","aria-label":'Permalink to "2.Spring循环依赖如何解决？"'},"​")],-1),e("p",null,"循环依赖问题在Spring中主要有三种情况：",-1),e("ul",null,[e("li",null,"通过构造方法进行依赖注入时产生的循环依赖问题。"),e("li",null,"通过setter方法进行依赖注入且是在多例（原型）模式下产生的循环依赖问题。"),e("li",null,"通过setter方法进行依赖注入且是在单例模式下产生的循环依赖问题。")],-1),e("p",null,"注意：在Spring中，只有【第三种方式】的循环依赖问题被解决了，其他两种方式在遇到循环依赖问题时都会产生异常。",-1),e("p",null,"其实也很好解释:",-1),e("ul",null,[e("li",null,"第一种构造方法注入的情况下，在new对象的时候就会堵塞住了，其实也就是”先有鸡还是先有蛋“的历史难题。"),e("li",null,"第二种setter方法&&多例的情况下，每一次getBean()时，都会产生一个新的Bean，如此反复下去就会有无穷无尽的Bean产生了，最终就会导致OOM问题的出现。")],-1),e("p",null,"Spring中有三个缓存，用于存储单例的Bean实例，这三个缓存是彼此互斥的，不会针对同一个Bean的实例同时存储。",-1),e("p",null,"如果调用getBean，则需要从三个缓存中依次获取指定的Bean实例。读取顺序依次是一级缓存–>二级缓存–>三级缓存",-1),e("div",{class:"language- vp-adaptive-theme"},[e("button",{title:"Copy Code",class:"copy"}),e("span",{class:"lang"}),e("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[e("code",{"v-pre":""},[e("span",{class:"line"},[e("span",null,"一级缓存：Map<String, Object> singletonObjects")])])]),e("button",{class:"collapse"})],-1),e("h3",{id:"第一级缓存的作用",tabindex:"-1"},[a("第一级缓存的作用？ "),e("a",{class:"header-anchor",href:"#第一级缓存的作用","aria-label":'Permalink to "第一级缓存的作用？"'},"​")],-1),e("ul",null,[e("li",null,"用于存储单例模式下创建的Bean实例（已经创建完毕）。"),e("li",null,"该缓存是对外使用的，指的就是使用Spring框架的程序员。")],-1),e("h3",{id:"存储什么数据",tabindex:"-1"},[a("存储什么数据？ "),e("a",{class:"header-anchor",href:"#存储什么数据","aria-label":'Permalink to "存储什么数据？"'},"​")],-1),e("ul",null,[e("li",null,"K：bean的名称"),e("li",null,"V：bean的实例对象（有代理对象则指的是代理对象，已经创建完毕）")],-1),e("div",{class:"language- vp-adaptive-theme"},[e("button",{title:"Copy Code",class:"copy"}),e("span",{class:"lang"}),e("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[e("code",{"v-pre":""},[e("span",{class:"line"},[e("span",null,"第二级缓存：Map<String, Object> earlySingletonObjects")])])]),e("button",{class:"collapse"})],-1),e("h3",{id:"第二级缓存的作用",tabindex:"-1"},[a("第二级缓存的作用？ "),e("a",{class:"header-anchor",href:"#第二级缓存的作用","aria-label":'Permalink to "第二级缓存的作用？"'},"​")],-1),e("ul",null,[e("li",null,"用于存储单例模式下创建的Bean实例（该Bean被提前暴露的引用,该Bean还在创建中）。"),e("li",null,"该缓存是对内使用的，指的就是Spring框架内部逻辑使用该缓存。"),e("li",null,"为了解决第一个classA引用最终如何替换为代理对象的问题（如果有代理对象）请爬楼参考演示案例")],-1),e("h3",{id:"存储什么数据-1",tabindex:"-1"},[a("存储什么数据？ "),e("a",{class:"header-anchor",href:"#存储什么数据-1","aria-label":'Permalink to "存储什么数据？"'},"​")],-1),e("ul",null,[e("li",null,"K：bean的名称"),e("li",null,"V：bean的实例对象（有代理对象则指的是代理对象，该Bean还在创建中）")],-1),e("div",{class:"language- vp-adaptive-theme"},[e("button",{title:"Copy Code",class:"copy"}),e("span",{class:"lang"}),e("pre",{class:"shiki shiki-themes github-light github-dark vp-code"},[e("code",{"v-pre":""},[e("span",{class:"line"},[e("span",null,"第三级缓存：Map<String, ObjectFactory<?>> singletonFactories")])])]),e("button",{class:"collapse"})],-1),e("h3",{id:"第三级缓存的作用",tabindex:"-1"},[a("第三级缓存的作用？ "),e("a",{class:"header-anchor",href:"#第三级缓存的作用","aria-label":'Permalink to "第三级缓存的作用？"'},"​")],-1),e("p",null,"通过ObjectFactory对象来存储单例模式下提前暴露的Bean实例的引用（正在创建中）。该缓存是对内使用的，指的就是Spring框架内部逻辑使用该缓存。此缓存是解决循环依赖最大的功臣",-1),e("h3",{id:"存储什么数据-2",tabindex:"-1"},[a("存储什么数据？ "),e("a",{class:"header-anchor",href:"#存储什么数据-2","aria-label":'Permalink to "存储什么数据？"'},"​")],-1),e("ul",null,[e("li",null,"K：bean的名称"),e("li",null,"V：ObjectFactory，该对象持有提前暴露的bean的引用")],-1),e("p",null,"为什么第三级缓存要使用ObjectFactory？需要提前产生代理对象。",-1),e("p",null,"什么时候将Bean的引用提前暴露给第三级缓存的ObjectFactory持有？时机就是在第一步实例化之后，第二步依赖注入之前，完成此操作。",-1),e("h2",{id:"_3",tabindex:"-1"},[a("3. "),e("a",{class:"header-anchor",href:"#_3","aria-label":'Permalink to "3."'},"​")],-1)])),"main-header":l(()=>[r(n.$slots,"main-header")]),"main-header-after":l(()=>[r(n.$slots,"main-header-after")]),"main-nav":l(()=>[r(n.$slots,"main-nav")]),"main-content":l(()=>[r(n.$slots,"main-content")]),"main-content-after":l(()=>[r(n.$slots,"main-content-after")]),"main-nav-before":l(()=>[r(n.$slots,"main-nav-before")]),"main-nav-after":l(()=>[r(n.$slots,"main-nav-after")]),comment:l(()=>[r(n.$slots,"comment")]),footer:l(()=>[r(n.$slots,"footer")]),aside:l(()=>[r(n.$slots,"aside")]),"aside-custom":l(()=>[r(n.$slots,"aside-custom")]),default:l(()=>[r(n.$slots,"default")]),_:3},8,["frontmatter"])}}};export{P as default};
